use dep::std::ec::consts::te::baby_jubjub;
use dep::std::ec::tecurve::affine::Point as TEPoint;

/*
export const Base8: Point<bigint> = [
    Fr.e(BigInt("5299619240641551281634865583518297030282874472190772894086521144482721001553")),
    Fr.e(BigInt("16950150798460657717958625567821834550301663161624707787222815936182638968203"))
]
*/

// Verify a share wrt commitments and x
fn main(x: Field, share: Field, c0_x: Field, c0_y: Field, c1_x: Field, c1_y: Field) {
  let bjj = baby_jubjub();
  
  let c0 = TEPoint::new(c0_x, c0_y);
  let c1 = TEPoint::new(c1_x, c1_y);

  // share * G = (secret + a*x) * G = secret*G + x*a*G
  let g = bjj.base8;//TEPoint::new(5299619240641551281634865583518297030282874472190772894086521144482721001553, 16950150798460657717958625567821834550301663161624707787222815936182638968203);
  let lhs = bjj.curve.mul(share, g);
  
  // c0 + x * c1 = secret*G + x*a*G
  let c1_x = bjj.curve.mul(x, c1);
  let rhs = bjj.curve.add(c1_x, c0);
  
  assert(lhs.x == rhs.x);
  assert(lhs.y == rhs.y);
}


fn main_scalar_impl(x: Field, share: Field, c0: Field, c1: Field) {
  let g: Field = 5;
  let lhs = pow_32_comptime(g, share);

  let temp = c1.pow_32(x);

  let rhs = c0*temp;
  assert(lhs == rhs);
}

unconstrained fn pow_32_comptime(base: Field, exponent: Field) -> Field {        
  let mut r: Field = 1;
  let b = exponent.to_le_bits(254);

  for i in 1..255 {
      r *= r;
      r = (b[254-i] as Field) * (r * base) + (1 - b[254-i] as Field) * r;
  }
  r
}

#[test]
fn test_verify_3() {
  // check_in_between();

  let share = 17214135709501589211635610146207934205025114056246378371601759642641757530912;
  let x = 1;
  let c0 = 8330058288412614655118243639940205745213215510503027084622385763556457009890;
  let c1 = 9906173667921276185696137786700386960735669367093897966488485273853345899244;
  main_scalar_impl(x, share, c0, c1);
}

#[test]
fn test_verify_1() {

//   secret 20290210470205734828292891540321552808182360429012389784437042414526616821886
// app.js?t=1707259396409:127 COEFF 12543159845200159138155575169669594118513053627063358988224035607179448993643
// app.js?t=1707259396409:79 pol[0] 20290210470205734828292891540321552808182360429012389784437042414526616821886
// app.js?t=1707259396409:80 pol[1] 12543159845200159138155575169669594118513053627063358988224035607179448993643
// share for 1 should be: 32833370315405893966448466709991146926695414056075748772661078021706065815529
// app.js?t=1707259396409:140 Share for 1: 10945127443566618744202060964733871838147049655659714428962873835130257319912
// app.js?t=1707259396409:140 Share for 2: 1600044416927502660111230389146190868111738882307039073488705255733897817938
// app.js?t=1707259396409:166 commitment 1766151923522387337830433922876673613960154223806436450979401652949358243573
// app.js?t=1707259396409:166 commitment 14887077490139691234110694366084099562618793428672272893133264192945096528056


  let x = 1;
  let share = 10945127443566618744202060964733871838147049655659714428962873835130257319912;

  let c0 = 1766151923522387337830433922876673613960154223806436450979401652949358243573;
  let c1 = 14887077490139691234110694366084099562618793428672272893133264192945096528056;
  main_scalar_impl(x, share, c0, c1);

}